name: sync-upstream

on:
  workflow_dispatch: {}
  schedule:
    - cron: "0 3 * * *" # nightly UTC

permissions:
  contents: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure git safe directory
        shell: bash
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"

      # 1) Resolve the latest UPSTREAM RELEASE (not tags)
      - name: Determine latest upstream release (Nasogaa/immich-drop)
        id: relmeta
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          GH_API: ${{ github.api_url }}
        run: |
          set -euo pipefail
          # Fetch most recent release (includes pre-releases; excludes drafts by default)
          URL="${GH_API:-https://api.github.com}/repos/Nasogaa/immich-drop/releases?per_page=1"
          HTTP="$(curl -sS \
            -H "authorization: Bearer ${GH_TOKEN}" \
            -H "accept: application/vnd.github+json" \
            -H "user-agent: gha-sync-upstream" \
            -w "%{http_code}" -o /tmp/releases.json "${URL}" || echo "000")"

          if [ "${HTTP}" != "200" ]; then
            echo "Failed to fetch upstream releases (HTTP ${HTTP})" >&2
            cat /tmp/releases.json || true
            exit 1
          fi

          TAG="$(jq -r '.[0].tag_name // empty' /tmp/releases.json)"
          BODY="$(jq -r '.[0].body // ""' /tmp/releases.json)"
          PUBLISHED="$(jq -r '.[0].published_at // ""' /tmp/releases.json)"
          HTML="$(jq -r '.[0].html_url // ""' /tmp/releases.json)"
          PRERELEASE="$(jq -r '.[0].prerelease // false' /tmp/releases.json)"

          if [ -z "${TAG}" ] || [ "${TAG}" = "null" ]; then
            echo "No upstream releases found" >&2
            exit 1
          fi

          {
            echo "tag=${TAG}"
            echo "published=${PUBLISHED}"
            echo "html=${HTML}"
            echo "prerelease=${PRERELEASE}"
            echo "body<<EOF"
            echo "${BODY}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      # 2) Read current add-on base version (without -X) from manifest
      - name: Read current add-on version
        id: current
        shell: bash
        run: |
          set -euo pipefail
          CUR="$(sed -n 's/^version:[[:space:]]*//p' immich-drop/config.yaml | head -n1 | tr -d '\r')"
          if [ -z "${CUR}" ]; then
            echo "Failed to read version from immich-drop/config.yaml" >&2
            exit 1
          fi
          BASE="$(echo "${CUR}" | sed -E 's/-[0-9]+$//')"
          echo "cur=${CUR}"   >> "$GITHUB_OUTPUT"
          echo "base=${BASE}" >> "$GITHUB_OUTPUT"

      # 3) Update files if upstream release tag changed
      - name: Update files if upstream release changed
        id: update
        shell: bash
        env:
          NEW_TAG: ${{ steps.relmeta.outputs.tag }}
          BASE: ${{ steps.current.outputs.base }}
        run: |
          set -euo pipefail
          echo "Upstream release tag: ${NEW_TAG}"
          echo "Current base version: ${BASE}"
          CHANGED=0

          if [ "${NEW_TAG}" != "${BASE}" ]; then
            echo "Bumping version to ${NEW_TAG} and resetting -X suffix"
            sed -i -E "s|^(version:[[:space:]]*).*$|\1${NEW_TAG}|" immich-drop/config.yaml
            CHANGED=1
          fi

          if ! grep -q "ARG UPSTREAM_REF=${NEW_TAG}" immich-drop/Dockerfile ; then
            sed -i -E "s|^ARG UPSTREAM_REF=.*$|ARG UPSTREAM_REF=${NEW_TAG}|" immich-drop/Dockerfile
            CHANGED=1
          fi

          echo "changed=${CHANGED}" >> "$GITHUB_OUTPUT"

      # 4) Decide which tag to (re)release and whether to release at all
      - name: Decide release/tag action
        id: decide
        shell: bash
        env:
          NEW_TAG: ${{ steps.relmeta.outputs.tag }}
          BASE: ${{ steps.current.outputs.base }}
          CHANGED: ${{ steps.update.outputs.changed }}
        run: |
          set -euo pipefail
          # If CHANGED==1 we release NEW_TAG; otherwise BASE.
          TO_USE="${NEW_TAG}"
          if [ "${CHANGED}" != "1" ]; then
            TO_USE="${BASE}"
          fi

          echo "DEBUG decide: NEW_TAG=${NEW_TAG} BASE=${BASE} CHANGED=${CHANGED} TO_USE=${TO_USE}"

          NEED_RELEASE=0
          if [ "${CHANGED}" = "1" ]; then
            echo "DEBUG decide: version changed -> need_release=1"
            NEED_RELEASE=1
          else
            # Determine if the tag exists on origin. ls-remote returns 0 even when no match,
            # so we must check if output is non-empty.
            OUT="$(git ls-remote --tags origin "refs/tags/${TO_USE}" || true)"
            if [ -n "${OUT}" ]; then
              echo "DEBUG decide: tag ${TO_USE} exists on origin"
            else
              echo "DEBUG decide: tag ${TO_USE} missing on origin -> need_release=1"
              NEED_RELEASE=1
            fi
          fi

          {
            echo "tag=${TO_USE}"
            echo "need_release=${NEED_RELEASE}"
          } >> "$GITHUB_OUTPUT"

      # 5) Compose changelog section using upstream release metadata
      - name: Compose changelog section from upstream release metadata
        if: ${{ steps.decide.outputs.need_release == '1' }}
        id: rel
        shell: bash
        env:
          TAG: ${{ steps.decide.outputs.tag }}
          BODY: ${{ steps.relmeta.outputs.body }}
          PUBLISHED: ${{ steps.relmeta.outputs.published }}
          HTML: ${{ steps.relmeta.outputs.html }}
        run: |
          set -euo pipefail
          mkdir -p /tmp
          SECTION="/tmp/changelog_section.md"

          if [ -n "${PUBLISHED}" ] && date -u -d "${PUBLISHED}" +"%Y-%m-%d" >/dev/null 2>&1; then
            DATE_FMT="$(date -u -d "${PUBLISHED}" +"%Y-%m-%d")"
          else
            DATE_FMT="$(date -u +"%Y-%m-%d")"
          fi

          {
            printf "## %s - %s\n\n" "${TAG}" "${DATE_FMT}"
            printf "Upstream release: %s\n\n" "${HTML:-https://github.com/Nasogaa/immich-drop/releases/tag/${TAG}}"
            if [ -n "${BODY}" ]; then
              printf "%s\n\n" "${BODY}"
            else
              printf "_No body provided by upstream release._\n\n"
            fi
          } > "${SECTION}"
          echo "section=${SECTION}" >> "$GITHUB_OUTPUT"

      # 6) Prepend CHANGELOG only when version changed (avoid duplicate entries)
      - name: Prepend CHANGELOG.md (root and add-on) with upstream notes
        if: ${{ steps.update.outputs.changed == '1' }}
        shell: bash
        env:
          SECTION: ${{ steps.rel.outputs.section }}
        run: |
          set -euo pipefail
          # Root CHANGELOG
          if [ -f CHANGELOG.md ]; then
            cat CHANGELOG.md >> "${SECTION}"
          fi
          mv "${SECTION}" CHANGELOG.md

          # Add-on local CHANGELOG (used by HA Add-on Store UI)
          SECTION2="/tmp/changelog_section_addon.md"
          cp CHANGELOG.md "${SECTION2}"
          if [ -f immich-drop/CHANGELOG.md ]; then
            cat immich-drop/CHANGELOG.md >> "${SECTION2}"
          fi
          mv "${SECTION2}" immich-drop/CHANGELOG.md

      # 7) Commit version bump and pin if CHANGED
      - name: Commit and push changes
        if: ${{ steps.update.outputs.changed == '1' }}
        shell: bash
        env:
          NEW_TAG: ${{ steps.relmeta.outputs.tag }}
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add immich-drop/config.yaml immich-drop/Dockerfile CHANGELOG.md
          git commit -m "chore(sync): track upstream ${NEW_TAG}; update CHANGELOG"
          git push

      # 8) Create the tag if needed (covers both changed and re-tag cases)
      - name: Create tag for release
        if: ${{ steps.decide.outputs.need_release == '1' }}
        shell: bash
        env:
          TAG: ${{ steps.decide.outputs.tag }}
          GIT_AUTHOR_NAME: github-actions[bot]
          GIT_AUTHOR_EMAIL: github-actions[bot]@users.noreply.github.com
          GIT_COMMITTER_NAME: github-actions[bot]
          GIT_COMMITTER_EMAIL: github-actions[bot]@users.noreply.github.com
        run: |
          set -euo pipefail
          # Ensure identity is configured for annotated tag creation
          git config user.name "${GIT_AUTHOR_NAME}"
          git config user.email "${GIT_AUTHOR_EMAIL}"

          if git ls-remote --tags origin "refs/tags/${TAG}" >/dev/null 2>&1; then
            echo "Tag ${TAG} already exists, skipping"
          else
            git tag -a "${TAG}" -m "Immich Drop add-on ${TAG}"
            git push origin "${TAG}"
          fi

      # 9) Publish release with upstream body
      - name: Publish GitHub Release
        if: ${{ steps.decide.outputs.need_release == '1' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.decide.outputs.tag }}
          name: ${{ steps.decide.outputs.tag }}
          body_path: ${{ steps.rel.outputs.section }}
          draft: false
          prerelease: ${{ steps.relmeta.outputs.prerelease == 'true' }}